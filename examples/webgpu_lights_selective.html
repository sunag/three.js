<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - tiled lighting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgpu - Compute-based Tiled Lighting<br />
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../src/Three.WebGPU.js",
					"three/tsl": "../src/Three.WebGPU.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { texture, uv, pass, userData, uniform } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			import { TiledLighting } from 'three/addons/lighting/TiledLighting.js';

			import Stats from 'three/addons/libs/stats.module.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer,
				lights,
				stats, controls,
				postProcessing;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 600 );
				camera.position.z = 200;
				camera.position.y = 30;

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x111111, 300, 500 );
				scene.background = new THREE.Color( 0x111111 );

				const sphereGeometry = new THREE.SphereGeometry( 0.1, 16, 8 );

				const material = new THREE.NodeMaterial();
				material.colorNode = userData( 'lightColor', 'color' );

				// lights

				lights = new THREE.Group();
				scene.add( lights );

				const addLight = ( hexColor, power = 10000, distance = 3 ) => {

					const mesh = new THREE.Mesh( sphereGeometry, material );
					mesh.userData.lightColor = new THREE.Color( hexColor );

					const light = new THREE.PointLight( hexColor, 1, distance );
					light.position.set( Math.random() * 300 - 150, 1, Math.random() * 300 - 150 );
					light.power = power;
					light.userData.fixedPosition = light.position.clone();
					light.add( mesh );

					lights.add( light );

					return light;

				};

				for ( let i = 0; i < 1000; i ++ ) {

					addLight( ( Math.random() * 0xffffff ) + 0x666666 );

				}

				//

				const lightAmbient = new THREE.AmbientLight( 0xffffff, .1 );
				scene.add( lightAmbient );

				// textures

				const textureLoader = new THREE.TextureLoader();

				const floorColor = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Diffuse.jpg' );
				floorColor.wrapS = THREE.RepeatWrapping;
				floorColor.wrapT = THREE.RepeatWrapping;
				floorColor.colorSpace = THREE.SRGBColorSpace;

				const floorNormal = textureLoader.load( 'textures/floors/FloorsCheckerboard_S_Normal.jpg' );
				floorNormal.wrapS = THREE.RepeatWrapping;
				floorNormal.wrapT = THREE.RepeatWrapping;

				const planeGeometry = new THREE.PlaneGeometry( 1000, 1000 );
				const planeMaterial = new THREE.MeshPhongNodeMaterial( {
					colorNode: texture( floorColor, uv().mul( 50 ) ),
					normalMap: floorNormal
				} );

				const ground = new THREE.Mesh( planeGeometry, planeMaterial );
				ground.rotation.x = - Math.PI / 2;
				ground.position.y = 0;
				ground.castShadow = true;
				ground.receiveShadow = true;
				scene.add( ground );

				// renderer

				const lighting = new TiledLighting(); // TiledLighting( maxLights = 1024, tileSize = 16 )

				renderer = new THREE.WebGPURenderer( { antialias: true, forceWebGL: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 5;
				renderer.lighting = lighting;
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxDistance = 400;

				// stats

				stats = new Stats();
				document.body.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

				// post processing

				const scenePass = pass( scene, camera );
				const bloomPass = bloom( scenePass, 3, .9, .2 );

				const tileInfluence = uniform( 0 );
				const tileBlockIndexes = lighting.getNode( scene, camera ).getBlock().toColor().div( 2048 );

				postProcessing = new THREE.PostProcessing( renderer );
				postProcessing.outputNode = scenePass.add( bloomPass ).add( tileBlockIndexes.mul( tileInfluence ) );

				// gui

				const gui = new GUI();
				gui.add( tileInfluence, 'value', 0, 1 ).name( 'tile indexes debug');

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const time = performance.now() / 1000;

				for ( const light of lights.children ) {

					const lightTime = ( time * 0.5 ) + light.id;

					light.position.copy( light.userData.fixedPosition );
					light.position.x += Math.sin( lightTime * 0.7 ) * 3;
					light.position.y += Math.cos( lightTime * 0.5 ) * .5;
					light.position.z += Math.cos( lightTime * 0.3 ) * 3;

				}

				postProcessing.render();

				stats.update();

			}

		</script>
	</body>
</html>
