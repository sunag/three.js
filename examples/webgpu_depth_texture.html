<html lang="en">
	<head>
		<title>three.js - WebGPU - Depth Texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Depth Texture
		</div>

		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { sub, floor, div, mul, timerLocal, oscSine, smoothstep, positionView, texture, color, viewportTexture, viewportTopLeft, viewportTopRight, cubeTexture, toneMapping, MeshStandardNodeMaterial, MeshBasicNodeMaterial } from 'three/nodes';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
			import WebGPUTextureRenderer from 'three/addons/renderers/webgpu/WebGPUTextureRenderer.js';

			import { RGBMLoader } from 'three/addons/loaders/RGBMLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, controls, renderer;

			const dpr = window.devicePixelRatio;

			init();

			async function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

				}

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, .3, 40 );
				camera.position.set( - 1.8, 0.6, 2.7 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222222 );

				const rgbmUrls = [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ];
				const cube1Texture = new RGBMLoader()
					.setMaxRange( 16 )
					.setPath( './textures/cube/pisaRGBM16/' )
					.loadCubemap( rgbmUrls );

				cube1Texture.generateMipmaps = true;
				cube1Texture.minFilter = THREE.LinearMipmapLinearFilter;

				scene.backgroundNode = cubeTexture( cube1Texture );
				scene.environmentNode = cubeTexture( cube1Texture );

				//

				//const geometry = new THREE.TorusKnotGeometry( 1, 0.3, 128, 64 );
				const geometry = new THREE.SphereGeometry( .7, 32, 16 );

				const count = 50;
				const scale = 5;

				for ( let i = 0; i < count; i ++ ) {

					const r = Math.random() * 2.0 * Math.PI;
					const z = ( Math.random() * 2.0 ) - 1.0;
					const zScale = Math.sqrt( 1.0 - z * z ) * scale;

					//const randColor = color( 0x0000ff );
					const randColor = color( 0xffffff * Math.random() );

					//const mesh = new THREE.Mesh( geometry, new MeshStandardNodeMaterial() );
					const mesh = new THREE.Mesh( geometry, new MeshBasicNodeMaterial() );
					
					mesh.material.colorNode = randColor;
					mesh.material.transparent = true;
					if ( i % 3 == 0 ) mesh.material.colorNode = viewportTexture( viewportTopLeft ).blur( oscSine( timerLocal( Math.random() * 2 ) ).mul( 3 ) ).add( color( 0x000033 ) );
					//if ( i % 3 == 0 ) mesh.material.colorNode = viewportTexture( viewportTopLeft ).rgb.oneMinus();

					//mesh.material.colorNode = randColor.add( viewportTexture.mul( .1 ) );

					mesh.position.set(
						Math.cos( r ) * zScale,
						Math.sin( r ) * zScale,
						z * scale
					);
					mesh.rotation.set( Math.random(), Math.random(), Math.random() );
					scene.add( mesh );

				}


				const mesh = new THREE.Mesh( new THREE.SphereGeometry( 2, 32, 16 ), new MeshBasicNodeMaterial() );
				scene.add( mesh );

				const mosaicSize = 90;

				const mosaic = floor( viewportTopLeft.mul( mosaicSize ) ).div( mosaicSize );
				
				//mesh.material.colorNode = viewportTexture( viewportTopLeft ).blur( oscSine( timerLocal( .5 ) ).mul( 5 ) ); // .oneMinus() // .add( .5 )
				//mesh.material.colorNode = viewportTexture( viewportTopLeft ).rgb.saturation( 0 ); // .oneMinus() // .add( .5 )
				mesh.material.colorNode = viewportTexture( viewportTopLeft ).blur( 4 );
				//mesh.material.colorNode = viewportTexture( mosaic ); // .oneMinus() // .add( .5 )
				mesh.material.transparent = true;

				//

				renderer = new WebGPURenderer();
				//renderer.setPixelRatio( dpr );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.outputColorSpace = THREE.SRGBColorSpace;
				renderer.toneMappingNode = toneMapping( THREE.LinearToneMapping, 1 );
				document.body.appendChild( renderer.domElement );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
